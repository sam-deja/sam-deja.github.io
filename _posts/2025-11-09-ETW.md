---

title: "EDR Telemetry Collection and Architecture"
date: 2025-11-09 11:00:00 -0700
categories: [security, edr]
tags: [edr, windows, etw, wfp, hooking]
mermaid: true
---

* The session covered endpoint detection and response (EDR) telemetry collection, focusing on Event Tracing for Windows (ETW) architecture and its role in telemetry gathering.
* ETW architecture consists of three main components: controllers, providers, and consumers.

  * **Controllers** manage ETW sessions by starting or stopping event collection and enabling or disabling ETW providers.
  * **Providers** act as event sources generating telemetry based on system or application activity. They can operate in either kernel mode (tracking process creation, file system operations, registry changes) or user mode (monitoring application-level events).
  * **Consumers** are applications or tools that process events, either in real time or by reading ETL (Event Trace Log) files stored on disk.
* ETW sessions handle the collection, buffering, and storage of event data. Each session keeps multiple buffers to temporarily store events, and multiple sessions can run simultaneously for different providers.
* Events generated may stay in memory buffers for real-time analysis or be logged into ETL files for later investigation.

```mermaid
%% ETW architecture: controllers, providers, consumers
flowchart LR
  A["Controllers"] -->|start/stop sessions<br/>enable/disable providers| B["ETW Sessions"]
  B --> C["Buffers & ETL files"]
  D["Providers<br/>(Kernel/User mode)"] --> B
  B --> E["Consumers<br/>(real-time / ETL readers)"]
```

# Windows Defender and ETW Integration

* Windows Defender uses ETW to collect security telemetry through two ETW sessions:

  * **Defender Audit Logger**
  * **Defender EPI Logger**
* Both sessions are located under `C:\Windows\System32\LogFiles\WMI\RtBackup`.
* The **Defender EPI Logger** session is associated with several ETW providers, including:

  * Microsoft-Windows-Scanner-General
  * Microsoft-Windows-EventLog
  * Microsoft-Windows-Storage-Intelligence
  * Microsoft-Windows-WMI-Activity
* These providers generate telemetry relevant to system events, network behaviors, and endpoint protection interactions.
* Defender consumes this telemetry in real time to detect malicious behaviors, identify suspicious activities, and improve threat detection.
* Security researchers use this data to understand Defender’s detection mechanisms, while attackers may attempt to evade by disabling providers or stopping ETW sessions.

```mermaid
%% Windows Defender ETW sessions & providers
flowchart TD
  subgraph S["ETW Sessions (RtBackup)"]
    A["Defender Audit Logger"]
    B["Defender EPI Logger"]
  end
  subgraph P["Providers (examples)"]
    P1["Microsoft-Windows-Scanner-General"]
    P2["Microsoft-Windows-EventLog"]
    P3["Microsoft-Windows-Storage-Intelligence"]
    P4["Microsoft-Windows-WMI-Activity"]
  end
  P1 --> B
  P2 --> B
  P3 --> B
  P4 --> B
  A & B --> C["Defender (consumer)"]
```

# Network Telemetry via Windows Filtering Platform (WFP)

* **Windows Filtering Platform (WFP)** is used to monitor and filter network traffic across logical layers of the network stack.
* Each layer contains IPv4 and IPv6 components that define specific network data fields.
* **Filters and callouts** are used to control traffic:

  * Filters apply conditions to network requests to allow, block, or modify traffic.
  * Callouts are optional kernel callbacks that extend filtering functionality.
* EDR solutions leverage WFP to inspect packets, track connections, and detect abnormalities such as command-and-control (C2) communications, data exfiltration, or suspicious file transfers.

```mermaid
%% WFP layers with filters & callouts
flowchart LR
  subgraph L["WFP Layers"]
    A["Application Layer"]
    B["Transport Layer"]
    C["Network Layer"]
    D["Link Layer"]
  end
  A --> B --> C --> D
  E["Filters (allow/block/modify)"] --- B
  F["Callouts (kernel extensions)"] --- C
```

# Process Monitoring and API Hooking

* EDR systems monitor process creation to collect detailed execution telemetry.
* Flow example:

  * A parent process (`parent.exe`) creates a new process (`malware.exe`).
  * The `CreateProcess` API in user mode transitions to kernel mode through `ntdll.dll` and `kernelbase.dll`.
  * The Windows kernel executes registered process creation callbacks.
  * The EDR driver (`edr.sys`) receives a callback, collects process metadata, and forwards it to the user-mode EDR process (`edr.exe`).
* To monitor system behavior, the EDR injects a DLL into the newly created process for API hooking.
* Inline hooking alters normal syscall execution by redirecting flow through a trampoline function in the EDR driver before calling the actual system service, allowing for inspection and logging of suspicious activity.
* After performing necessary checks, the hook function restores the legitimate execution path and completes the system call if no threat is detected.

```mermaid
%% Process creation & user-mode hooking
sequenceDiagram
  participant P as "parent.exe"
  participant CP as "CreateProcess (user mode)"
  participant N as "ntdll.dll / kernelbase.dll"
  participant K as "Kernel"
  participant D as "edr.sys (driver)"
  participant U as "edr.exe (user-mode)"
  participant I as "Injected DLL (hooks)"
  P->>CP: "CreateProcess(malware.exe)"
  CP->>N: "Transition to native"
  N->>K: "Syscall to create process"
  K-->>D: "Process creation callback"
  D-->>U: "Telemetry (PID, image, cmdline)"
  U-->>I: "Inject monitoring DLL"
```

```mermaid
%% Inline hooking trampoline
flowchart TD
  A["App calls API"] --> B["Hooked function prologue"]
  B --> C["Jump to trampoline (EDR driver)"]
  C --> D["Inspection / logging"]
  D --> E["Call real system service"]
  E --> F["Return to original flow"]
```

# Advanced Detection and Response Mechanisms

* Modern EDRs employ multiple detection mechanisms to enhance protection:

  * AI and machine learning–based anomaly detection to identify suspicious behavioral patterns.
  * **Cloud submission and scanning** for deep analysis using cloud-based intelligence.
  * **YARA rule and signature-based scanning** to detect known malware patterns in files or memory.
  * **Threat hunting automation** for continuous scanning of indicators of compromise (IOCs).
  * **Sandboxing** to safely execute and analyze potentially malicious files.
  * **Deception technology** employing decoy files, fake credentials, and honey tokens to detect intrusions.
  * **Exploit mitigation** through stack integrity checks and memory protection techniques to block common exploitation methods.
